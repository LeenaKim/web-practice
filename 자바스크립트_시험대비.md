[toc]





# 기본

- boolean()

  > false로 변환 : 0, NaN, ""[빈문자열], **null**, undefined

- null

  	> Null 값을 가진 객체(object)

  

# 배열

- 한 배열에 여러 다양한 자료형이 올 수 있음

  ## 메소드

  - `array.push("end")` : 배열의 끝에 요소 추가 

  - `array.pop()` : 배열 마지막 요소를 삭제하고 해당 요소를 반환 

  - `array.length` : 배열의 길이 

  - `array.sort()` : 문자의 경우 가나다순으로 정렬되지만 숫자의 경우 숫자를 문자로 인식해서 첫글자의 ascii 코드가 가장 작은 요소부터 정렬함. 

    - 문자 정렬

      ```javascript
      var books = ['신데렐라', '콩쥐팥쥐', '피터팬', '백설공주'];
      books.sort()
      ```

    - 정수형 오름차순 정렬

      ```javascript
      nums.sort(function(left, right) {
      		return left - right; 
      	})
      ```

    - 정수형 내림차순 정렬

      ```javascript
      	nums.sort(function(left, right) {
      		return right - left; 
      	})
      ```

      

  ## 배열 출력법

  > ```javascript
  > // 방법 1
  > 	for(var i = 0; i < names.length; i++){
  > 		document.write(names[i] + "<br>");
  > 	}
  > // 방법 2
  > 	for(var i in names){// i는 names 안의 원소를 말하는게 아니라 인덱스를 뜻한다.
  > 		document.write(names[i] + '<br>');
  > 	}
  > // 방법 3
  > 	for(var name of names){
  > 		document.write(name + '<br>');
  > 	}
  > // 방법 4
  > 	nums.forEach(function(element, index, nums) {
  > 		document.write(`${ index }번째 정수는 ${ element }<br>`);	// nums 내의 요소의 개수만큼 이 함수를 호출해줘! - forEach의 콜백함수의 매개변수 수는 3개. 1. element 2. index 3. 배열  
  > 		document.write(nums + '<br>')
  > 	})
  > 	
  > ```

  

  ## Deep copy & Shallow copy

  - **shallow copy** : copyArray에서만 바꿔도 array도 바뀜. 두 변수 모두 같은 주소값을 참조하기때문. 
  - **deep copy** : copyArray에서 바꾸면 array는 안바뀜. 값 자체를 복사해서 다른 주소값을 참조하기때문에.

  ```javascript
  // DeepCopy 방법 1 
  var copyArray =[];
  for(let data of array){
  	copyArray.push(data);
  }
  // DeepCopy 방법 2 
  var copyArray2 = [...array]; 	// ...array : array의 모든 요소
  
  // DeepCopy 방법 3
  	// forEach처럼 요소 개수만큼 돈다. 
  var copyNums = nums.map(function(element) {
  	return	element + 100; // 요소마다 100을 더해서 새로운 배열로 딥카피 
  })
  ```

  ## '키'처럼 작용하는 인덱스

  자바스크립트의 배열은 인덱스로 숫자뿐만아니라 키값이 올 수 있다. 그래서 배열도 일종의 객체의 멤버변수들처럼 보일 수 있다.

  ```javascript
  state['서초'] = '서울특별시';
  	state['철산'] = '경기도';
  	state['해운대'] = '부산광역시';
  	
  	for(var index in state){
  		document.write(index + " : " + state[index] + '<br>');
  	}
  
  var person = new Array();	// 객체가 아니라 배열인데 객체의 멤버변수들처럼 보임. 
  	person['name'] = '홍길동';
  	person['phone'] = '010-1111-2222';
  	person['address'] = '서울시 서초구';
  	person.gender = 'M';
  	
  	for(var key in person){
  		document.write(key + ' : ' + person[key] + '<br>');
  	}
  ```

  


# 변수

## Var

> 호이스팅이 일어나 먼저 var로 선언된 변수들을 정의하고 프로그램을 시작. 
>
> 블록 스코프의 개념이 없다.

## Let

> 호이스팅이 일어나지 않는다.
>
> 블록 스코프에 따라 선언된 블록 안에서만 동작한다. 
>
> 현대 자바스크립트는 let을 많이 사용. 
>
> 같은 이름으로 두번 선언할 수 없다. 
>
> ```javascript
> 	{
> 		var temp = 1000;
> 		let letTemp = 2000;
> 		alert(`temp : ${ temp }, letTemp : ${ letTemp }`);
> 	}
> 	alert(`temp : ${ temp }, letTemp : ${ letTemp }`);
> 	// let과 const 변수는 block scope 형태이다. 블록 안에서 생성된 let 변수는 블록이 끝나면 사라지기때문에 alert구문에 letTemp에서 에러가 난다. 
> 	
> ```
>
> 

## const

> 상수변수. 값을 한번 선언하면 바꿀 수 없다. 

# 함수 

자바스크립트의 함수는 자료형이라 익명함수시 숫자, 분자열, 불처럼 변수에 넣어서 사용.

자바스크립트에서는 함수의 이름만 의미있다. 오버로드라는 개념이 없고 매개변수를 다르게 줘도 함수의 내용부가 재정의, 재정의 된 것이다.

그래서 맨 마지막에 선언된 aaa 함수가 실제 실행되는 함수다. 함수도 호이스팅이 일어나는것.

## 익명함수

> 이름을 붙이지 않고 함수를 생성 
>
> 호이스팅이 안일어나서 선언 후에만 호출 가능 
>
> ```javascript
> let a = function () {};
> console.log(a); 			// [Function] 출력 
> ```
> ```javascript
> 
> ```



## 선언적 함수

> 이름을 붙여 함수를 생성
>
> 같은 이름의 선언적, 익명 함수가 있다면 익명 함수가 무조건 우선순위가 높음. 익명함수가 호이스팅이 안되서 무조건 선언적 함수보다 나중에 선언되기 때문. 
>
> ```javascript
> function a () {}
> console.log(a); 		// [Function: a] 출력 
> ```
> :star:**익명 함수와 선언적 함수의 생성 순서**
>
> ​	익명함수 : 위에서부터 한줄 한줄 읽어내려가며 함수를 선언하고 변수에 할당. 덮어쓰기 가능
>
> ​	선언적 함수 : *'코드를 실항하기 전'*에 생성
>
> ```javascript
> a = function () {console.log('first func')};	// 익명함수 
> function a() {console.log('second func')};		// 선언적 함수 
> // => 선언적 함수 먼저 생성 후 익명함수가 덮어씀. 즉, 익명함수만 출력됨. 
> ```

## 전개연산자 : 여러개의 요소를 매개변수로 넘겨줄때

> ```javascript
> function func03(...numbers) {
> 		console.log(numbers);
> 	}
> 	
> 	function func04(a, b, ...numbers){
> 		document.write('a : ' + a + '<br>');
> 		document.write('b : ' + b + '<br>');
> 		document.write('numbers : ' + numbers + '<br>');
> 	}
> 	
> 	var array = [1, 2, 3];
> 	
> 	func04(...array);												// a : 1, b : 2, numbers : 3
> 	func04(...array, ...array);							// a : 1, b : 2, numbers : 3, 1, 2, 3
> 	func04(...array, ...array, ...array);
> ```
>
> 

## 화살표 함수[ECMAScript6]

> 익명 함수를 더 간단하게 생성
>
> '하나의 표시식을 리턴하는 함수'를 만들떈 중괄호 생략 가능 
>
> ```javascript
> let 함수 = () => {
> 함수 내용 
> };
> 
> //
> var add = function(a, b){
> return a + b;
> }
> // 람다식 
> //var add = (a, b) => {return a + b};
> var add = (a, b) => a + b;
> alert(add(10, 20));
> ```
>

## 콜백함수

> 함수의 매개변수로 전달되는 함수
>
> 자기 함수를 수행후 매개변수로 받은 함수를 호출한다. 동적인 함수. 사용자가 그때그때 정의 가능하기때문. 
>
> ```javascript
> function callTenTimes(callback){
> 	for(let i = 0; i < 10; i++){
> 		callback();
> 	}
> }
> 
> callTenTimes(function () {
> console.log('call func');
> })
> ```

## `arguments` : 자바스크립트에서 디폴트로 생성되있는 변수. 함수에 들어오는 매개변수를 배열형태로 받는다. 

>```javascript
 	>function aaa() {
 	>		console.log(arguments);
 	>	}
 	>	
  	>	aaa(10, 20, 30, 40, 50);
	>	aaa("hello", 20);
	>	
	>/* ------------------------------------------ */
	>	
	>	function aaa() {
	>		switch(arguments.length){
	>		case 0 :
	>			alert('call aaa()...');
	>			break;
	>		case 1 :
	>			alert('data : ' + arguments[0]);
	>			break;
	>		case 2 :
	>			alert('a : ' + arguments[0] + ', b : ' + arguments[1]);
	>			break;
	>		}
	>	}
	>```

## 매개변수 디폴트값

> ```javascript
> function func(a, b, c){
> 		/* 방법 1 
> 		if(a === undefined)
> 			a = 0;
> 		if(b === undefined)
> 			b = 0;
> 		if(c === undefined)
> 			c = 0;
> 		*/
> 		
> 		// boolean(undefined) 와 boolean(null), boolean(0) 은 false, 나머지 true
> 		// 방법 2 
> 		if(!a) a = 0;
> 		if(!b) b = 0;
> 		if(!c) c = 0;
> 		
> 		alert('a : ' + a + ', b : ' + b + ', c : ' + c);
> 	}
> 	// 방법 3
> 	function func(a,b,c){
> 		a = a || 0; // a가 trued이면 a 에 a 대입, false면 a에 0 대입 
> 		b = b || 0;
> 		c = c || 0;
> 		
> 		alert('a : ' + a + ', b : ' + b + ', c : ' + c);
> 	}
> 	// 방법 4
> 	function func(a = 0,b = 0,c = 0){// 날라오는 매개변수가 없으면 0으로 초기화해라. 	
> 		alert('a : ' + a + ', b : ' + b + ', c : ' + c);
> ```

## Closer : 함수를 리턴

> ```javascript
 	> 
 	> 	function returnFunc(name){
  	> 		var msg = '반갑습니다' + name + '님!!!';
	> 		
	> 		// closer : 함수를 리턴 
	> 		return function() {// msg는 함수가 끝나면 사라지는 변수. 하지만 함수를 리턴할떄 함수를 호출하면 return에 있는 함수가 끝날때까진 msg가 사라지지 않는다. 
	> 			alert(msg);
	> 		};
	> 	}
	> 	
	> 	var f = returnFunc('홍길동');
	> 	f();
	> 	f();// 몇번을 호출하던 실행됨. msg를 f()가 계속 갖고있기때문. 
	> 	
	> 	// 보통은 returnFunc('홍길동')(); 이렇게 호출. 
	> ```
	>
	> ```javascript
	> // setTimeout는 웹브라우저에서 하는게 아니라 시간을 가지고 해야하기때문에 호출하는순간 제어권이 나를 떠나 다른곳으로 넘어가고, 그곳에서 수행된다음 1초 후 다시 돌아온다. 
	> // 자바스크립트에 정의한것들이 먼저 하나씩 수행된 후 모두 끝나면 setTimeout이 수행된다. 
	> // 그래서 i가 2까지 모두 돌고난 후 3이 되어 false가 되어 반복문이 종료될때 timeout 함수가 실행되고, 밀렸던 출력 세번을 모두 3으로 출력한다. 
	> // 이런 문제를 해결하기 위해 closer을 쓴다. 	
	> 	for(var i = 0; i < 3; i++){
	> 		setTimeout(function() {
	> 			alert(i);
	> 		}, 0);
	> 	}
	> 
	> /* closer 활용한 코드 */
	> var func = function(i) {
	> 		setTimeout(function() {
	> 			alert(i);// i값을 유지하기위해 closer 사용 
	> 		}, 0);
	> 	}
	> 	
	> 	for(var i = 0; i < 3; i++){
	> 		func(i);
	> 	}
	> 
	> ```
	>
	> 

## 표준 내장 함수

- 숫자변환함수
  - `parseInt()` : 문자열중 숫자문자열은 숫자로 변환 
  - `parseFloat()`
  - `Number` : 오직 숫자문자열로 이뤄진 아이만 변환가능 
  
  ```javascript
  var won = '1000원';
  	var dollar = '1.78$';
  	
  	document.write('Number : ' + Number(won) + '<br>');// NaN 나옴. '원' 변환 불가능 
  	document.write('parseInt : ' + parseInt(won) + '<br>');// 1000 나옴. 1000까지만 변환 
  	document.write('parseInt : ' + parseInt(dollar) + '<br>');// 1
  	document.write('parseFloat : ' + parseFloat(dollar) + '<br>');// 1.78 소숫점까지 나옴.  
  ```
  
  
  
  ## 타이머함수
  
  - `setTimeout(함수, ms)` :  ms 지난 후 함수 실행 		ex)스케줄러 알림 앱  
  - `setInterval(함수, ms)` : ms가 경과할때마다 함수 실행  ex)반복되는 일과 알림 
  - `clearInterval(id)` :  해당 id를 가진 interval 삭제
  - `clearTimeout(id)` : 해당 id를 가진 timeout 삭제 
  
  ```javascript
  var id = setInterval(function() {
  		document.write('현재시간 : ' + new Date() + '<br>');
  	}, 1000);
  	
  	setTimeout(function() {
  		clearInterval(id);
  		alert('날짜쓰기 종료... '); // 마지막 10번째 document.write은 alert이 수행된 후에만 출력된다. 왜? 10초가 되는순간 두 함수가 동시호출되는데 이때 alert이 document.write보다 상위함수라서. 
  	}, 10000);
  ```
  
  
  
  
  
  ## 코드 실행 함수
  
  - eval(str)
  
  ```javascript
  var str = 'alert("hello");';
  		str += 'var number = 10;';
  		str += 'alert(number);';
  		str += 'var array = [10, 12.34, true, "good"];';
  		str += 'alert("배열의 요소개수: " + array.length + "개");';
  	
  	eval(str); // str이 가지고있는 문자열이 자바스크립트라면, 걜 실행해! 
  	
  	number += 30;
  	alert('number : ' + number); // 답은 40. 문자열 내에서 정의된 함수도 실제로 남아있다. 
  	
  ```
  
  

# 객체

## 선언 방법

```javascript
var person = {
		name : '홍길동',
		phone : '010-1111-2222',
		'phone-home' : '02-1111-2222'// 속성명의 따옴표 생략가능하지만 속성명에 특수기호가 들어가면 따옴표로 묶어줘야함 
	};
	
	document.write('속성 name 존재여부 : ' + ('name' in person) + '<br>');// T

// 자바스크립트는 없던 멤버변수도 새로 추가하여 값을 입력할 수 있다. 
	person.addr = '경기도 광명시';
	console.log(person);
	
	document.write('속성 addr 존재여무 : ' + ('addr' in person) + '<br>');// T 

// 있던 속성을 지울수도 있다. 
	delete(person.addr)
	
	document.write('속성 addr 존재여무 : ' + ('addr' in person) + '<br>');// F 
```

## 객체 속성 접근 방법

```javascript
person.name;
person['name']; // 속성 안에 띄어쓰기나 특수문자가 들어가있을경우 
```

## 객체 선언시 함수

```javascript
var person ={
      'name' : '홍길동',
      'phone' : 1234,
      'addr' : '경기도 광명시',
      'info' : function() {
        for(var key in this){// key는 속성명, this[key]는 해당 속성의 값 
             if((typeof this[key]) != 'function')         //info 제외
                document.write(key + " : " + this[key] + '<br>')   // 자바와 달리 this 필수적
                //여기서는 .이 아닌 []를 써야함 - .쓰면 속성명이 name, phone처럼 key를 찾게됨!
          }
      }               
   }
```

## toString 메소드 

```javascript
 person.toString = function(){         
      //정의되어 있지 않아도 사용할 수 있따. 모든 객체는 object를 받기 때문에 (object 안에 tostring이 있음)
      let msg = '';
      for(let key in this){
         if((typeof this[key] != 'function'))
            msg += `${ key } : ${ this[key] }<br>`
      }
      return msg
   }
// with : person 객체 안에 있는 
with(person){
      info();
   }
   
person.info();
```

## 객체 깊은복사 얕은복사

```javascript
// 얕은 복사 
	//var person2 = person;
	

	// 깊은 복사
	// 방법 3 
	var person2 = {...person};
	// 방법 2 
	var person2 = clone(person);
	
	// 방법 1 
	var person2 = {};
	for(let key in person){
		person2[key] = person[key];
	}
	*/
```



## 생성자함수와 프로토타입

객체 배열을 이용해 여러개의 객체를 만들어낼 수 있긴 하지만, 만약 객체에 대한 메소드를 만들어야할경우 객체마다 같은 메소드를 여러번 반복해서 선언해줘야한다는 번거로움이 있다. '한 객체의 속성과 기능은 한 객체를 기준으로 처리할 수 있게 한다'는 규칙성을 지키기 위해 도입된것이 생성자함수와 프로토타입.

- 생성자함수

```javascript
/* 반환값이 따로 없어도 new 키워드로 생성하는 함수. 
	사실 자바스크립트는 객체라는 개념이 없고 다 함수형태다. 
	new로 인해 할당된 메모리가 프로토타입을 가리킨다. 
	내 안에 프로토타입을 갖고있으면 객체라 부른다. 
	생성자함수는 프로토타입을 갖게하는 함수이다. 
	*/
	function Person(name, phone, addr){
		this.name = name;// new를 이용해서 객체의 공간을 만들고, 날라온 매개변수를 동적으로 멤버변수로 추가 
		this.phone = phone;
		this.addr = addr;
		
		this.info = function() {
			var msg = '';
			for(let key in this){
				if((typeof this[key] != 'function'))
					msg += key + ' : ' + this[key] + '<br>'
			}
			document.write(msg);
		}
	}
	
	var p = new Person('홍길동', '010-1111-2222', '서울시 서초구');
	//console.log(p);
	// 생성자를 이용해서 객체생성시 콘솔창을 보면 전에 var p = function()으로 만들었을때는 Object형으로 나온것에 반해 Person형으로 나옴. 

```

- 프로토타입

  생성자 함수로 만든 객체는 프로토타입이라는 공간에 메소드를 지정해서 모든 객체가 공유하도록 만들 수 있다. 

  ```javascript
   p.info();
  	
  	var p2 = new Person();
  	p2.info();
  	
  	// p1과 p2가 서로 공유하는 info 같은 함수는 두 객체 모두가 가진 prototype 공간에 만든다. 두번 생성되는 메모리 낭비를 줄이기위해. 
  	Person.prototype.aaa = function() {
  		alert('aaa')
  	}
  	console.log(p);// console창에 proto에 aaa함수가 정의된걸 확인. 정의할땐 형.prototype.함수이름을 쓰지만, 호출할땐 똑같이 변수명.함수이름만 가지고 호출. 
  
  	p.aaa();
  	
  	document.write('p instanceof Person: ' + (p instanceof Person) + '<br>');
  	
  	//aaa 함수 재선언시 다 바뀌는 효과를 가짐 
  	Person.prototype.aaa = function() {
  		alert('change...');
  	}
  	
  	p.aaa();
  	p2.aaa();
  	
  	// 객체형.프로토타입.함수가 아니라 객체.함수를 재정의할경우 해당 객체가 가진 함수의 내용만 바뀐다. 마치 메소드 오버라이드. 내 객체에 선언된 함수가 먼저, 그게 없으면 프로토타입에서 선언된 함수까지 간다. 
  	p.aaa = function() {
  		alert('p에서 정의한 aaa()')
  	}
  ```

  ```javascript
  // Person.prototype.hobby = '숨쉬기'; // 꼭 함수만 프로토타입으로 정할 수 있는것이 아니라 변수도 가능
  
  Person.prototype.info = function() {
  	var msg = '';
  	for(let key in this){
  		if((typeof this[key] != 'function'))
  			msg += key + ' : ' + this[key] + '<br>'
  	}
  	document.write(msg);
  }
  
  function Doctor(name, phone, addr, major) {
  	
  	this.super = Person; 					// super은 변수명일뿐 
  	this.super(name, phone, addr);
  	
  	//Person.apply(this, arguments)			// apply() : 배열을 넘겨주면 배열 인자 하나하나가 Persion()의 매개변수 하나하나로 넘겨진다. 
  	//Person.call(this, name, phone, addr) 	// call() : person 생성자 호출하겠다 
  										 	// this : person의 this에 저장하지 말고 doctor의 this.name, phone, addr에 저장해라. 
  	this.major = major
  }
  
  Doctor.prototype = Person.prototype; // doctor의 프로토타입을 person의 프로토타입과 같게함. 얘가 없으면 doctor.info()를 호출하면 에러남. 
  
  ```

  

  ## 은닉성

  ```javascript
  function Person(n, p, a){
  		//this.name = n; 외부에서 접근 가능
  		let name = n;// 멤버변수가 아니라 자바스크립트의 함수 내의 변수로 선언해주면 멤버변수를 은닉할 수 있음. 
  		var phone = p;
  		var addr = a;
  		/*
  		this.getName = function() {// 대신 getter로 값만 알 수 있게함. 
  			return name;
  		}
  		*/
  		this.getName = ()=>name;
  		
  		this.setName = function(n){
  			name = n;
  		}
  	}
  ```

  ## 클래스

  ```javascript
  class Person {
  		// new를 하는순간 호출되는 생성자 
  		constructor(name, phone, addr){
  			this._name = name;		// 클래스의 함수도 객체.함수이름이고, 변수도 객체.변수로 콘솔창에서 호출한다.
  			this._phone = phone;	// 그래서 person.name을 하면 name을 호출해서 가져오지만, 사실 변수 이름은 _name이다.
  			this._addr = addr;		// 즉, 이중보안이 된다는 뜻. 
  		}
  		// getter/setter
  		get name() {
  			return this._name;
  		}
  		
  		set name(name) {
  			this._name = name;
  		}
  		
  		get phone() {
  			return this._phone;
  		}
  		
  		set phone(phone) {
  			this._phone = phone;
  		}
  		
  		get addr() {
  			return this._addr;
  		}
  		
  		set addr(addr) {
  			this._addr = addr;
  		}
  		info() {
  			alert(`name : ${ this._name }\nphone : ${ this._phone }\naddr : ${ this._addr }`);
  		}
  	}
  	
  	class Doctor extends Person {// extends로 인해 프로토타입도 옮겨간다. 
  		constructor(name, phone, addr, major) {
  			super(name, phone, addr); // 클래스 내에서의 super은 예약어이지만, exam09에서 function형태로 세운 객체의 super은 단순 변수이다. 
  			this._major = major;
  		}
  	
  		set major(major){
  			this._major = major
  		}
  		
  		get major(major) {
  			return this._major = major
  		}
  	}
  	
  	let person = new Person('홍길동', '010-1111-2222', '서울시 서초구');
  	console.log(person);
  	person.info();
  	
  	let doctor = new Doctor('나최고', '010-3333-4444', '경기도 용인시');
  	console.log(doctor);
  ```



## JSON

JSON (JavaScript Object Notation) : **자바스크립트 객체**를 의미 

- api 쓸때 json 객체로 받아다가 parse시켜서 객체화시켜서 멤버변수들을 .으로 접근 가능 

- 백엔드와 프론트엔드간 데이터를 주고받을때 JSON으로 주고받는다. 



< 메소드 >

- `JSON.stringify()` : JSON 객체의 값을 문자열로 변환시켜주는 함수
- `JSON.parse()` : 자바스크립트 문자열을 자바스크립트 객체로 다시 바꿔주는 함수 

```javascript
let person = {
			'name' : '홍길동',
			'phone' : '010-1111-2222',
			'addr' : '서울시 서초구 서초동',
			toJSON : function() {
				return {// 실제 멤버변수는 세개지만 난 두개만 넘기겠다 - 콘솔에 name, addr만 나옴. 
					"name" : this.name,
					"addr" : this.addr
				}
			}
	}

// 객체 -> 문자열 
let strPerson = JSON.stringify(person)
  
// 문자열 -> 객체 
let obj = JSON.parse(strPerson)
  
 document.write('name : ' + obj.name  + ', phone : ' + obj.phone + ', addr : ' + obj.addr);

let str = '{"id" : "hong", "password" : "1234"}';

//	let obj2 = eval(str)	// eval함수는 파싱 인식을 잘 못함. 
let obj2 = JSON.parse(str);
console.log(obj2)
document.write('<hr>');
document.write('id : ' + obj2.id + ', password : ' + obj2.password);
```



# 표준내장객체

- 기본자료형 객체

  Number, Boolean, String은 자바스크립트의 기본자료형으로, new 연산자를 쓰지 않고도 선언할 수 있다. 하지만 이들이 기본연산자 클래스의 메소드를 쓸 수 있는건 그냥 선언을 해도 메소드를 호출할땐 객체로 변환되었다가 다시 돌아오기 때문이다. 기본 자료형이 속성 또는 메소드를 추가하려면 프로토타입으로 일회용 옷 자체를 바꾸면 된다.  

  ```javascript
  var num = 10;
  	var num2 = new Number(10);
  
  	document.write('num : ' + num + ':' + (typeof num) + '<br>'); 		// number형 (기본자료형) - 프로토타입 정의 불가능 
  	document.write('num2 : ' + num2 + ':' + (typeof num2) + '<br>'); 	// object형 - 프로토타입 정의 가능 
  
  	Object.prototype.info = function() {
  		alert(this)
  	}
  
  	num.info() 	// 기본자료형이라 원래 안되야함 
  	num2.info() // object형이라 원래 얘만 되야함
  	
  ```

- String 객체는 비파괴적 메소드가 주여서 문자열 자체를 바꾸지 않지만, 배열은 파괴적 메소드가 주여서 배열 자체가 바뀐다. 



# 웹브라우저의 자바스크립트(BOM)

- 브라우저 객체모델(BOM) : 웹 브라우저와 관련된 객체 

  ## Window 객체 

  웹 페이자 자체를 나타냄. 

  window.onload를 통해 html의 body를 만드는 이유 : body에 정의되는 코드는 정적인 html. 자바스크립트에서 정의되는 코드는 동적인 Html. 만약 화면에서 내가 html에 변화를 주고싶다면 자스로 해야한다. ex) 댓글달때 내 댓글 등록되어 화면이 바뀌는 효과 등. 

  ```javascript
  console.log(document.body);
  	
  	window.onload = function() {
  		console.log(document.body);
  		// window.onload는 body까지 다 실행한후에 실행되므로 document.body가 null이 아니지만, 바로 console.log(document.body)를 찍으면 null. body가 아직 실행 안됬기 때문. 
  	
  	}
  ```

  

  - `alert(<메시지>)`
  - `prompt(<메시지>)`

  ```javascript
  let sub = open("", "", "width = 400, height = 400"); // 팝업창 
  	if(!sub){	// null일경우 false니까 팝업창 안뜰경우 null이되며 false가 됨 
  		alert('팝업창 옵션을 확인하세요. ');
  	}
  	sub.moveTo(100, 100);
  	
  	setInterval(function() {
  		sub.moveBy(20, 20);
  	}, 1000)
  ```

  ```javascript
  var sub = window.open("", "", "width=400, height=400");
  	
  	// screen 객체 : 사용자 컴퓨터의 가로 세로 정보가 들어있는 객체 
  	let width = screen.width;
  	let height = screen.height;
  	
  	//sub.moveTo(0,0);	// 상대적 위치는 moveBy. moveTo는 절대 위치 
  	//sub.resizeTo(width, height); // 절대적 크기를 resize 
  	
  	// 화면 시간마다 줄어들고 크게하기 
  	setInterval(function() {
  		sub.resizeBy(-20, -20);
  	}, 1000)
  ```

  ```javascript
  <heap>
  <script>
  	
  	let audio = new Audio()
  	audio.src = "/Lecture-WEB/html/playlist/눈물구름4.mp3";
  	
  </script>
  </heap>
  <body>
  	<!-- window.onload 함수를 안만들어도 audio 객체 내의 play, pause 등의 내장함수를 이용 -->
  	<input type = "button" value = "PLAY" onclick = "audio.play()"> 
  	<input type = "button" value = "STOP" onclick = "audio.pause()">
  </body>
  ```

  

  ## Screen 객체

  운영체제 화면의 속성 객체

  - `width` : 화면 너비
  - `height` : 화면 높이

  ## Location 객체

  웹브라우저의 주소창과 관련 (프로토콜 종류, 호스트 이름, 문서 위치 정보 등)

  <메소드>

  - `assign(<링크>)` : 매개변수로 전달한 위치로 이동
  - `reload()` : 새로고침
  - `replace()` : 매개 변수로 전달한 위치로 이동

  ```javascript
  if(confirm('네이버로 이동하시겠습니까?')){
  		
  		//location.href = "http://www.naver.com";
  		//location = "http://www.naver.com";
  		location.assign('http://www.naver.com');
  	}
  ```

  

  ## history 객체

  웹 브라우저의 앞으로 가기, 뒤로가기와 관련

  < 메소드 >

  - `forword()` : 앞으로 이동
  - `back()` : 뒤로 이동

  ## navigator 객체

  웹 페이지를 실행하는 웹 브라우저 정보가 들어있음



# 문서 객체 모델 (DOM)

넓은 의미로 웹 브라우저가 HTML 페이지를 인식하는 방법, 좁은 의미로는 document 객체와 관련된 객체의 집합을 나타냄 

> - HTML 페이지의 태그를 읽으며 생성하는것 : 정적으로 문서 객체를 생성
> - 자바스크립트를 사용해 프로그램 실행중에 문서 객체를 생성 : 동적으로 문서 객체를 생성

HTML 코드를 위에서 아래로 실행한다. 

- 문서 객체 선택

  - `document.getElementById(아이디)` 

  - `document.querySelector(선택자)`

    주의 : 매개변수로 전달한 CSS 선택자로 선택되는 첫번째 태그만 선택

  - `document.getElementsByName(이름)`

  - `document.getElementsByClassName(클래스)`

  - `document.querySelectorAll(선택자)`

  - `document.createElement(선택자)` : 태그 생성

  ```javascript
  var id = document.querySelector('#id');		// 같은 기능 
  		//console.log(id)
  		id.innerHTML = '아이디';	// id가 'id'인 아이의 텍스트를 '아이디'로 바꿔줌. 
  		
  		var password = document.querySelector('.pwd');
  		//console.log(password);
  		password.innerText = '패스워드';
  ```

  ```javascript
  window.onload = function() {
  		var tag = document.createElement('h1');			// 태그 만들기 
  		var tagText = document.createTextNode("Hello");	// 태그 내용 채우기 
  		tag.appendChild(tagText); // 부모는 h1 자식은 Hello. 부모인 tag에 자식인 tagText를 append 시킴. 
  		document.body.appendChild(tag); // 더 상위 부모인 body에 append 
  		
  		var imgTag = document.createElement('img');
  		imgTag.src = "https://t1.daumcdn.net/daumtop_chanel/op/20170315064553027.png";
  		//document.body.appendChild(imgTag);
  ```

  

- 문서 객체 조작

  - `InnerHTML` :  html 태그 안의 다른 태그와 그 내용물을 뽑아낸다.
  - `InnerText` :  태그는 떼고 실제 텍스트만 나오게. 

- 문서 객체 삭제

  - `parentNode` : 해당 선택자의 부모 태그 객체
  - `removeChild(obj)` : 자식태그 삭제 
  - `remove()` : 태그 바로 지우기

  ```javascript
  window.onload = function() {
  		let idTag = document.getElementById('id');
  		idTag.parentNode.removeChild(idTag); 	// idTag의 부모를 찾아서 그의 자식중 하나를 지우려하는데, 그 자식의 아이디가 idTag인놈 
  	//	idTag.remove();		// idTag 자체를 지움 
  }
  ```

  

- cf) CSS에서 '-'로 표현되는건 자바스크립트에선 카멜표기법으로 

- 속성조작

  - `setAttribute(속성이름, 속성값)` : 속성값 지정
  - `getAttribute(속성이름)` : 속성 추출

  ```javascript
  var aTag = document.createElement('a');
  		console.log(aTag);
  		// 방법 1
  		//aTag.href = "https://www.daum.net";
  		//aTag.target = '_blank';
  		// 방법 2
  		aTag.setAttribute('href', 'http://www.daum.net');
  		aTag.setAttribute('target', '_blank');
  		aTag.appendChild(imgTag);
  		document.body.appendChild(aTag);
  ```

  

- 이벤트 : 키보드로 키를 입력하거나 마우스 클릭 등 어떤 현상이 프로그램에 영향을 미치는것을 의미

  - Window.onload = function() {}

    onload : 이벤트 속성 / load : 이벤트이름 or 이벤트타입 / function(){} : 이벤트 리스너 or 이벤트 핸들러 

    이벤트모델 : 문서 객체에 이벤트를 연결하는 방법

  - :star:이벤트 모델

    - **DOM Level 0**

      - 인라인 이벤트 모델
      - 고전 이벤트 모델

      ```html
      <!-- 인라인 이벤트모델 -->
      	<input type="button" value = "클릭하세요" onclick="alert('click...')":> <!-- 인라인 방식의 이벤트 모델 : 코드에 직접 스크립트 작성 -->
      	<input type="button" value = "3초타이머" onclick="clickTimer()"><!-- 일일히 태그마다 써주기 힘드니 함수를 만들어주는게 좋음. -->
      	
      	<!-- 고전적 이벤트모델 -->
      	<input type="button" value="클릭2" id="clickBtn">
      ```

    - **DOM Level 2**

      - 마이크로소프트 인터넷 익스플로러 이벤트 모델
      - 표준 이벤트 모델 

      ```javascript
      /* 
      	DOM Level 2
      	표준이벤트모델 - addEventListener(이벤트속성, handler, capturing 사용여부)
      */
      	window.onload = function() {
      		let btn = document.getElementById('btn');
      		btn.addEventListener('click', function() {	// onclick 대신 속성명 click만. 
      			alert('button click...');
      		}, true)
      		
      		// 이벤트 버블링 발생 -> span의 click -> button의 click 발생 (하위에서 상위태그로 이벤트가 올라감)
      		// 하지만 버튼쪽에 이벤트 캡쳐링을 true로 만들면 상위에서 하위쪽으로 이벤트가 내려감. (=이벤트 버블링 false)
      		// 디폴트는 버블링이 캡쳐링보다 우선. 캡쳐링을 true로 만드는순간 캡쳐링이 우선. 
      		let span = document.querySelector('span')
      		span.addEventListener('click', function() {
      			alert('span click...')
      		})
      	}
      ```

      

    - :star:이벤트 버블링 

      하위 태그에서 정의된 이벤트를 그 태그의 부모 태그를 타고들어가며 해당 이벤트를 적용시키는 것.

      `cancelBubble`: false - 버블링 허용 

      ```javascript
      window.onload = function() {
      		var span = document.querySelector('span')
      		var h1 = document.querySelector('h1')
      		var div = document.querySelector('div')
      		
      		span.onclick = function(e) {//매개변수는 이벤트의 e
      			alert('click span...')
      			console.log(e)
      		}
      		
      		h1.onclick = function(e) {
      			alert('click h1...')
      			e.cancelBubble = true// 버블링을 취소하니 div가 나옴 
      			console.log(e)
      		}
      		
      		div.onclick = function(e) {
      			alert('click div...')
      		}
      	}
      ```

    - :star:이벤트 캡쳐링

      상위 태그에서 정의된 이벤트를 그 태그의 자식 태그를 타고들어가며 해당 이벤트를 적용시키는 것. => DOM Level 2 참조 

    - check box 활용

      ```javascript
      // 지금은 window.onload가 필요 없다. showInfo()를 클릭했다는건 이미 웹브라우저가 다 뜬 후라서. 
      
      function toggle(check){
      		for(let i in document.inputForm.hobby){
      			document.inputForm.hobby[i].checked = check;
      		}
      }
      	
      function toggle(){
      	let hobbys = document.inputForm.hobby
          
       	let check = false;
      	// 하나라도 false가 있다면 check 변수를 true로 바꿔준다. 
      	for(let i = 0; i < hobbys.length; i++){
      		if(!hobbys[i].checked){
      			check = true;
      			break;
      		}
      	}
      	// false가 하나도 없으면 check은 false 
      	for(let i = 0; i < hobbys.length; i++){
      		hobbys[i].checked = check;// 하나라도 false가 있으면 전체를 true로, false가 없으면 전체를 false로 
      	} 
      ```

      ```html
      <body>
      <!-- document.name으로 접근할 수 있는 태그는 유일하게 Form태그뿐. document.inputForm.hobby -->
      	<form action="" name="inputForm"> <!-- form태그는 name 속성 필수 -->
      		당신의 취미는? <br><!-- 단일선택은 Radio, 복수선택은 check box -->
      		<input type="checkbox" name="hobby" value="음악감상">음악감상<br>	<!-- value : 해당 Input이 갖는 값. 보통 영어로 써준다. -->
      		<input type="checkbox" name="hobby"	value="movie">영화감상<br>
      		<input type="checkbox" name="hobby" value="등산">등산<br>
          .....(생략)
      </body>
      ```

      

    - form 태그 활용

      document.searchForm.searchType 							=> select의 리스트를 볼 수 있다.

      document.searchForm.searchType.selectedIndex 	=> 현재 선택된 옵션의 인덱스가 나온다. 

      document.searchForm.searchType[i].selected 		  => 해당 옵션이 선택되었는지 아닌지

      document.wearchForm.searchWord.value				 => searchWord 이름을 가진 태그의 값. 비어있을시 ""

      ```html
      <script> 
      	function checkForm() {
      		let f = document.searchForm
      		
      		// if(f.searchType.selectedIndex == 0){
      		if(f.searchType[0].selected) {
      			alert('검색 항목을 선택하세요.');
      			f.searchType.focus(); // 사용자가 선택하지 않은 개체로 커서가 움직인다. 
      			return false;
      		} 
      		
      		let words = ['', '제목', '작성자'];
      		if(f.searchWord.value == ''){
      			alert('검색할 ' + words[f.searchType.selectedIndex] + '을(를) 입력하세요.');
      			f.searchWord.focus();
      			return false;
      		}
      		
      		if(f.searchWord.value.length < 2){
      			alert('검색어는 2글자 이상 입력하세요. ')
      			f.searchWord.focus();
      			return false;
      		}
      		return true;
      	}
      </script>
      </head>
      <body>
      	<form action="http://www.naver.com" name="searchForm" onsubmit="return checkForm()"> 
      	<!-- onsubmit : submit으르 허용할까요 말까요 = action url로 갈까요 말까요 
      		return true 	: 가겠다 
      		return false 	: 안가겠다 
      		return 함수()		: 때에 따라 달라진다 -->
      		<select name="searchType">
      			<option>선택하세요</option>
      			<option>제목</option>
      			<option>작성자</option>
      		</select>
      		<input type="text" name="searchWord">
      		<input type="submit" value="검색">
      	</form>
      </body>
      ```

      

