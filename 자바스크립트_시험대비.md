[toc]







# 기본

- boolean()

  > false로 변환 : 0, NaN, ""[빈문자열], **null**, undefined

- null

  	> Null 값을 가진 객체(object)

  

# 배열

- 한 배열에 여러 다양한 자료형이 올 수 있음

- 메소드

  - `array.push("end")` : 배열의 끝에 요소 추가 

  - `array.pop()` : 배열 마지막 요소를 삭제하고 해당 요소를 반환 

  - `array.length` : 배열의 길이 

  - `array.sort()` : 문자의 경우 가나다순으로 정렬되지만 숫자의 경우 숫자를 문자로 인식해서 첫글자의 ascii 코드가 가장 작은 요소부터 정렬함. 

    - 문자 정렬

      ```javascript
      var books = ['신데렐라', '콩쥐팥쥐', '피터팬', '백설공주'];
      books.sort()
      ```

    - 정수형 오름차순 정렬

      ```javascript
      nums.sort(function(left, right) {
      		return left - right; 
      	})
      ```

    - 정수형 내림차순 정렬

      ```javascript
      	nums.sort(function(left, right) {
      		return right - left; 
      	})
      ```

      

-  배열 출력법

  > ```javascript
  > // 방법 1
  > 	for(var i = 0; i < names.length; i++){
  > 		document.write(names[i] + "<br>");
  > 	}
  > // 방법 2
  > 	for(var i in names){// i는 names 안의 원소를 말하는게 아니라 인덱스를 뜻한다.
  > 		document.write(names[i] + '<br>');
  > 	}
  > // 방법 3
  > 	for(var name of names){
  > 		document.write(name + '<br>');
  > 	}
  > // 방법 4
  > 	nums.forEach(function(element, index, nums) {
  > 		document.write(`${ index }번째 정수는 ${ element }<br>`);	// nums 내의 요소의 개수만큼 이 함수를 호출해줘! - forEach의 콜백함수의 매개변수 수는 3개. 1. element 2. index 3. 배열  
  > 		document.write(nums + '<br>')
  > 	})
  > 	
  > ```

  

- Deep copy & Shallow copy

  - **shallow copy** : copyArray에서만 바꿔도 array도 바뀜. 두 변수 모두 같은 주소값을 참조하기때문. 
  - **deep copy** : copyArray에서 바꾸면 array는 안바뀜. 값 자체를 복사해서 다른 주소값을 참조하기때문에.

  ```javascript
  // DeepCopy 방법 1 
  var copyArray =[];
  for(let data of array){
  	copyArray.push(data);
  }
  // DeepCopy 방법 2 
  var copyArray2 = [...array]; 	// ...array : array의 모든 요소
  
  // DeepCopy 방법 3
  	// forEach처럼 요소 개수만큼 돈다. 
  var copyNums = nums.map(function(element) {
  	return	element + 100; // 요소마다 100을 더해서 새로운 배열로 딥카피 
  })
  ```

- '키'처럼 작용하는 인덱스

  자바스크립트의 배열은 인덱스로 숫자뿐만아니라 키값이 올 수 있다. 그래서 배열도 일종의 객체의 멤버변수들처럼 보일 수 있다.

  ```javascript
  state['서초'] = '서울특별시';
  	state['철산'] = '경기도';
  	state['해운대'] = '부산광역시';
  	
  	for(var index in state){
  		document.write(index + " : " + state[index] + '<br>');
  	}
  
  var person = new Array();	// 객체가 아니라 배열인데 객체의 멤버변수들처럼 보임. 
  	person['name'] = '홍길동';
  	person['phone'] = '010-1111-2222';
  	person['address'] = '서울시 서초구';
  	person.gender = 'M';
  	
  	for(var key in person){
  		document.write(key + ' : ' + person[key] + '<br>');
  	}
  ```

  

# 변수

- Var

  > 호이스팅이 일어나 먼저 var로 선언된 변수들을 정의하고 프로그램을 시작. 
  >
  > 블록 스코프의 개념이 없다.

- Let

  > 호이스팅이 일어나지 않는다.
  >
  > 블록 스코프에 따라 선언된 블록 안에서만 동작한다. 
  >
  > 현대 자바스크립트는 let을 많이 사용. 
  >
  > 같은 이름으로 두번 선언할 수 없다. 
  >
  > ```javascript
  > 	{
  > 		var temp = 1000;
  > 		let letTemp = 2000;
  > 		alert(`temp : ${ temp }, letTemp : ${ letTemp }`);
  > 	}
  > 	alert(`temp : ${ temp }, letTemp : ${ letTemp }`);
  > 	// let과 const 변수는 block scope 형태이다. 블록 안에서 생성된 let 변수는 블록이 끝나면 사라지기때문에 alert구문에 letTemp에서 에러가 난다. 
  > 	
  > ```
  >
  > 
  
- const

  	> 상수변수. 값을 한번 선언하면 바꿀 수 없다. 

# 함수 

자바스크립트의 함수는 자료형이라 익명함수시 숫자, 분자열, 불처럼 변수에 넣어서 사용.

자바스크립트에서는 함수의 이름만 의미있다. 오버로드라는 개념이 없고 매개변수를 다르게 줘도 함수의 내용부가 재정의, 재정의 된 것이다.

그래서 맨 마지막에 선언된 aaa 함수가 실제 실행되는 함수다. 함수도 호이스팅이 일어나는것.

- 익명함수

  > 이름을 붙이지 않고 함수를 생성 
  >
  > 호이스팅이 안일어나서 선언 후에만 호출 가능 
  >
  > ```javascript
  > let a = function () {};
  > console.log(a); 			// [Function] 출력 
  > ```
  > ```javascript
  > var add = function(a, b){
	> return a + b;
	> }
	> // 람다식 
> //var add = (a, b) => {return a + b};
> var add = (a, b) => a + b;
	> alert(add(10, 20));
	> ```
	
	
	
- 전개연산자 : 여러개의 요소를 매개변수로 넘겨줄때

  > ```javascript
  > function func03(...numbers) {
  > 		console.log(numbers);
  > 	}
  > 	
  > 	function func04(a, b, ...numbers){
  > 		document.write('a : ' + a + '<br>');
  > 		document.write('b : ' + b + '<br>');
  > 		document.write('numbers : ' + numbers + '<br>');
  > 	}
  > 	
  > 	var array = [1, 2, 3];
  > 	
  > 	func04(...array);												// a : 1, b : 2, numbers : 3
  > 	func04(...array, ...array);							// a : 1, b : 2, numbers : 3, 1, 2, 3
  > 	func04(...array, ...array, ...array);
  > ```
  >
  > 



- 선언적 함수

  > 이름을 붙여 함수를 생성
  >
  > 같은 이름의 선언적, 익명 함수가 있다면 익명 함수가 무조건 우선순위가 높음. 익명함수가 호이스팅이 안되서 무조건 선언적 함수보다 나중에 선언되기 때문. 
  >
  > ```javascript
  > function a () {}
  > console.log(a); 		// [Function: a] 출력 
  > ```
  > :star:**익명 함수와 선언적 함수의 생성 순서**
  >
  > ​	익명함수 : 위에서부터 한줄 한줄 읽어내려가며 함수를 선언하고 변수에 할당. 덮어쓰기 가능
  >
  > ​	선언적 함수 : *'코드를 실항하기 전'*에 생성
  >
  > ```javascript
  > a = function () {console.log('first func')};	// 익명함수 
  > function a() {console.log('second func')};		// 선언적 함수 
  > // => 선언적 함수 먼저 생성 후 익명함수가 덮어씀. 즉, 익명함수만 출력됨. 
  > ```

- 화살표 함수[ECMAScript6]

  > 익명 함수를 더 간단하게 생성
  >
  > '하나의 표시식을 리턴하는 함수'를 만들떈 중괄호 생략 가능 
  >
  > ```javascript
  > let 함수 = () => {
  >   함수 내용 
  > };
  > ```
  > 


- 콜백함수

  > 함수의 매개변수로 전달되는 함수
  >
  > 자기 함수를 수행후 매개변수로 받은 함수를 호출한다. 동적인 함수. 사용자가 그때그때 정의 가능하기때문. 
  >
  > ```javascript
  > function callTenTimes(callback){
  > 	for(let i = 0; i < 10; i++){
  > 		callback();
  > 	}
  > }
  > 
  > callTenTimes(function () {
  > console.log('call func');
  > })
  > ```

- `arguments` : 자바스크립트에서 디폴트로 생성되있는 변수. 함수에 들어오는 매개변수를 배열형태로 받는다. 

  	>```javascript
    	>function aaa() {
    	>		console.log(arguments);
    	>	}
    	>	
  	>	aaa(10, 20, 30, 40, 50);
  	>	aaa("hello", 20);
  	>	
  	>/* ------------------------------------------ */
  	>	
  	>	function aaa() {
  	>		switch(arguments.length){
  	>		case 0 :
  	>			alert('call aaa()...');
  	>			break;
  	>		case 1 :
  	>			alert('data : ' + arguments[0]);
  	>			break;
  	>		case 2 :
  	>			alert('a : ' + arguments[0] + ', b : ' + arguments[1]);
  	>			break;
  	>		}
  	>	}
  	>```
  
- 매개변수 디폴트값

  > ```javascript
  > function func(a, b, c){
  > 		/* 방법 1 
  > 		if(a === undefined)
  > 			a = 0;
  > 		if(b === undefined)
  > 			b = 0;
  > 		if(c === undefined)
  > 			c = 0;
  > 		*/
  > 		
  > 		// boolean(undefined) 와 boolean(null), boolean(0) 은 false, 나머지 true
  > 		// 방법 2 
  > 		if(!a) a = 0;
  > 		if(!b) b = 0;
  > 		if(!c) c = 0;
  > 		
  > 		alert('a : ' + a + ', b : ' + b + ', c : ' + c);
  > 	}
  > 	// 방법 3
  > 	function func(a,b,c){
  > 		a = a || 0; // a가 trued이면 a 에 a 대입, false면 a에 0 대입 
  > 		b = b || 0;
  > 		c = c || 0;
  > 		
  > 		alert('a : ' + a + ', b : ' + b + ', c : ' + c);
  > 	}
  > 	// 방법 4
  > 	function func(a = 0,b = 0,c = 0){// 날라오는 매개변수가 없으면 0으로 초기화해라. 	
  > 		alert('a : ' + a + ', b : ' + b + ', c : ' + c);
  > ```

- Closer : 함수를 리턴

  	> ```javascript
    	> 
    	> 	function returnFunc(name){
  	> 		var msg = '반갑습니다' + name + '님!!!';
  	> 		
  	> 		// closer : 함수를 리턴 
  	> 		return function() {// msg는 함수가 끝나면 사라지는 변수. 하지만 함수를 리턴할떄 함수를 호출하면 return에 있는 함수가 끝날때까진 msg가 사라지지 않는다. 
  	> 			alert(msg);
  	> 		};
  	> 	}
  	> 	
  	> 	var f = returnFunc('홍길동');
  	> 	f();
  	> 	f();// 몇번을 호출하던 실행됨. msg를 f()가 계속 갖고있기때문. 
  	> 	
  	> 	// 보통은 returnFunc('홍길동')(); 이렇게 호출. 
  	> ```
  	>
  	> ```javascript
  	> // setTimeout는 웹브라우저에서 하는게 아니라 시간을 가지고 해야하기때문에 호출하는순간 제어권이 나를 떠나 다른곳으로 넘어가고, 그곳에서 수행된다음 1초 후 다시 돌아온다. 
  	> // 자바스크립트에 정의한것들이 먼저 하나씩 수행된 후 모두 끝나면 setTimeout이 수행된다. 
  	> // 그래서 i가 2까지 모두 돌고난 후 3이 되어 false가 되어 반복문이 종료될때 timeout 함수가 실행되고, 밀렸던 출력 세번을 모두 3으로 출력한다. 
  	> // 이런 문제를 해결하기 위해 closer을 쓴다. 	
  	> 	for(var i = 0; i < 3; i++){
  	> 		setTimeout(function() {
  	> 			alert(i);
  	> 		}, 0);
  	> 	}
  	> 
  	> /* closer 활용한 코드 */
  	> var func = function(i) {
  	> 		setTimeout(function() {
  	> 			alert(i);// i값을 유지하기위해 closer 사용 
  	> 		}, 0);
  	> 	}
  	> 	
  	> 	for(var i = 0; i < 3; i++){
  	> 		func(i);
  	> 	}
  	> 
  	> ```
  	>
  	> 

- 표준 내장 함수

  - 숫자변환함수
    - `parseInt()` : 문자열중 숫자문자열은 숫자로 변환 
    - `parseFloat()`
    - `Number` : 오직 숫자문자열로 이뤄진 아이만 변환가능 
    
    ```javascript
    var won = '1000원';
    	var dollar = '1.78$';
    	
    	document.write('Number : ' + Number(won) + '<br>');// NaN 나옴. '원' 변환 불가능 
    	document.write('parseInt : ' + parseInt(won) + '<br>');// 1000 나옴. 1000까지만 변환 
    	document.write('parseInt : ' + parseInt(dollar) + '<br>');// 1
    	document.write('parseFloat : ' + parseFloat(dollar) + '<br>');// 1.78 소숫점까지 나옴.  
    ```
    
    
    
  - 타이머함수
    - `setTimeout(함수, ms)` :  ms 지난 후 함수 실행 		ex)스케줄러 알림 앱  
    - `setInterval(함수, ms)` : ms가 경과할때마다 함수 실행  ex)반복되는 일과 알림 
    - `clearInterval(id)` :  해당 id를 가진 interval 삭제
    - `clearTimeout(id)` : 해당 id를 가진 timeout 삭제 
    
    ```javascript
    var id = setInterval(function() {
    		document.write('현재시간 : ' + new Date() + '<br>');
    	}, 1000);
    	
    	setTimeout(function() {
    		clearInterval(id);
    		alert('날짜쓰기 종료... '); // 마지막 10번째 document.write은 alert이 수행된 후에만 출력된다. 왜? 10초가 되는순간 두 함수가 동시호출되는데 이때 alert이 document.write보다 상위함수라서. 
    	}, 10000);
    ```
    
    
    
    
    
  - 코드 실행 함수
  
    - eval(str)
  
    ```javascript
    var str = 'alert("hello");';
    		str += 'var number = 10;';
    		str += 'alert(number);';
    		str += 'var array = [10, 12.34, true, "good"];';
    		str += 'alert("배열의 요소개수: " + array.length + "개");';
    	
    	eval(str); // str이 가지고있는 문자열이 자바스크립트라면, 걜 실행해! 
    	
    	number += 30;
    	alert('number : ' + number); // 답은 40. 문자열 내에서 정의된 함수도 실제로 남아있다. 
    	
    ```
  
    

# 객체

- 선언 방법

  ```javascript
  var person = {
  		name : '홍길동',
  		phone : '010-1111-2222',
  		'phone-home' : '02-1111-2222'// 속성명의 따옴표 생략가능하지만 속성명에 특수기호가 들어가면 따옴표로 묶어줘야함 
  	};
  	
  	document.write('속성 name 존재여부 : ' + ('name' in person) + '<br>');// T
  
  // 자바스크립트는 없던 멤버변수도 새로 추가하여 값을 입력할 수 있다. 
  	person.addr = '경기도 광명시';
  	console.log(person);
  	
  	document.write('속성 addr 존재여무 : ' + ('addr' in person) + '<br>');// T 
  
  // 있던 속성을 지울수도 있다. 
  	delete(person.addr)
  	
  	document.write('속성 addr 존재여무 : ' + ('addr' in person) + '<br>');// F 
  ```

- 객체 속성 접근 방법

  ```javascript
  person.name;
  person['name']; // 속성 안에 띄어쓰기나 특수문자가 들어가있을경우 
  ```

- 객체 선언시 함수

  ```javascript
  var person ={
        'name' : '홍길동',
        'phone' : 1234,
        'addr' : '경기도 광명시',
        'info' : function() {
          for(var key in this){// key는 속성명, this[key]는 해당 속성의 값 
               if((typeof this[key]) != 'function')         //info 제외
                  document.write(key + " : " + this[key] + '<br>')   // 자바와 달리 this 필수적
                  //여기서는 .이 아닌 []를 써야함 - .쓰면 속성명이 name, phone처럼 key를 찾게됨!
            }
        }               
     }
  ```

- toString 메소드 

  ```javascript
   person.toString = function(){         
        //정의되어 있지 않아도 사용할 수 있따. 모든 객체는 object를 받기 때문에 (object 안에 tostring이 있음)
        let msg = '';
        for(let key in this){
           if((typeof this[key] != 'function'))
              msg += `${ key } : ${ this[key] }<br>`
        }
        return msg
     }
  // with : person 객체 안에 있는 
  with(person){
        info();
     }
     
  person.info();
  ```

- 객체 깊은복사 얕은복사

  ```javascript
  // 얕은 복사 
  	//var person2 = person;
  	
  
  	// 깊은 복사
  	// 방법 3 
  	var person2 = {...person};
  	// 방법 2 
  	var person2 = clone(person);
  	
  	// 방법 1 
  	var person2 = {};
  	for(let key in person){
  		person2[key] = person[key];
  	}
  	*/
  ```

  

- 생성자함수와 프로토타입

  객체 배열을 이용해 여러개의 객체를 만들어낼 수 있긴 하지만, 만약 객체에 대한 메소드를 만들어야할경우 객체마다 같은 메소드를 여러번 반복해서 선언해줘야한다는 번거로움이 있다. '한 객체의 속성과 기능은 한 객체를 기준으로 처리할 수 있게 한다'는 규칙성을 지키기 위해 도입된것이 생성자함수와 프로토타입.

  - 생성자함수

  ```javascript
  /* 반환값이 따로 없어도 new 키워드로 생성하는 함수. 
  	사실 자바스크립트는 객체라는 개념이 없고 다 함수형태다. 
  	new로 인해 할당된 메모리가 프로토타입을 가리킨다. 
  	내 안에 프로토타입을 갖고있으면 객체라 부른다. 
  	생성자함수는 프로토타입을 갖게하는 함수이다. 
  	*/
  	function Person(name, phone, addr){
  		this.name = name;// new를 이용해서 객체의 공간을 만들고, 날라온 매개변수를 동적으로 멤버변수로 추가 
  		this.phone = phone;
  		this.addr = addr;
  		
  		this.info = function() {
  			var msg = '';
  			for(let key in this){
  				if((typeof this[key] != 'function'))
  					msg += key + ' : ' + this[key] + '<br>'
  			}
  			document.write(msg);
  		}
  	}
  	
  	var p = new Person('홍길동', '010-1111-2222', '서울시 서초구');
  	//console.log(p);
  	// 생성자를 이용해서 객체생성시 콘솔창을 보면 전에 var p = function()으로 만들었을때는 Object형으로 나온것에 반해 Person형으로 나옴. 
  
  ```

- 프로토타입

  생성자 함수로 만든 객체는 프로토타입이라는 공간에 메소드를 지정해서 모든 객체가 공유하도록 만들 수 있다. 

  ```javascript
   p.info();
  	
  	var p2 = new Person();
  	p2.info();
  	
  	// p1과 p2가 서로 공유하는 info 같은 함수는 두 객체 모두가 가진 prototype 공간에 만든다. 두번 생성되는 메모리 낭비를 줄이기위해. 
  	Person.prototype.aaa = function() {
  		alert('aaa')
  	}
  	console.log(p);// console창에 proto에 aaa함수가 정의된걸 확인. 정의할땐 형.prototype.함수이름을 쓰지만, 호출할땐 똑같이 변수명.함수이름만 가지고 호출. 
  
  	p.aaa();
  	
  	document.write('p instanceof Person: ' + (p instanceof Person) + '<br>');
  	
  	//aaa 함수 재선언시 다 바뀌는 효과를 가짐 
  	Person.prototype.aaa = function() {
  		alert('change...');
  	}
  	
  	p.aaa();
  	p2.aaa();
  	
  	// 객체형.프로토타입.함수가 아니라 객체.함수를 재정의할경우 해당 객체가 가진 함수의 내용만 바뀐다. 마치 메소드 오버라이드. 내 객체에 선언된 함수가 먼저, 그게 없으면 프로토타입에서 선언된 함수까지 간다. 
  	p.aaa = function() {
  		alert('p에서 정의한 aaa()')
  	}
  ```

  ```javascript
  // Person.prototype.hobby = '숨쉬기'; // 꼭 함수만 프로토타입으로 정할 수 있는것이 아니라 변수도 가능
  
  Person.prototype.info = function() {
  	var msg = '';
  	for(let key in this){
  		if((typeof this[key] != 'function'))
  			msg += key + ' : ' + this[key] + '<br>'
  	}
  	document.write(msg);
  }
  
  function Doctor(name, phone, addr, major) {
  	
  	this.super = Person; 					// super은 변수명일뿐 
  	this.super(name, phone, addr);
  	
  	//Person.apply(this, arguments)			// apply() : 배열을 넘겨주면 배열 인자 하나하나가 Persion()의 매개변수 하나하나로 넘겨진다. 
  	//Person.call(this, name, phone, addr) 	// call() : person 생성자 호출하겠다 
  										 	// this : person의 this에 저장하지 말고 doctor의 this.name, phone, addr에 저장해라. 
  	this.major = major
  }
  
  Doctor.prototype = Person.prototype; // doctor의 프로토타입을 person의 프로토타입과 같게함. 얘가 없으면 doctor.info()를 호출하면 에러남. 
  
  ```

  

- 은닉성

  ```javascript
  function Person(n, p, a){
  		//this.name = n; 외부에서 접근 가능
  		let name = n;// 멤버변수가 아니라 자바스크립트의 함수 내의 변수로 선언해주면 멤버변수를 은닉할 수 있음. 
  		var phone = p;
  		var addr = a;
  		/*
  		this.getName = function() {// 대신 getter로 값만 알 수 있게함. 
  			return name;
  		}
  		*/
  		this.getName = ()=>name;
  		
  		this.setName = function(n){
  			name = n;
  		}
  	}
  ```

- 클래스

  ```javascript
  class Person {
  		// new를 하는순간 호출되는 생성자 
  		constructor(name, phone, addr){
  			this._name = name;		// 클래스의 함수도 객체.함수이름이고, 변수도 객체.변수로 콘솔창에서 호출한다.
  			this._phone = phone;	// 그래서 person.name을 하면 name을 호출해서 가져오지만, 사실 변수 이름은 _name이다.
  			this._addr = addr;		// 즉, 이중보안이 된다는 뜻. 
  		}
  		// getter/setter
  		get name() {
  			return this._name;
  		}
  		
  		set name(name) {
  			this._name = name;
  		}
  		
  		get phone() {
  			return this._phone;
  		}
  		
  		set phone(phone) {
  			this._phone = phone;
  		}
  		
  		get addr() {
  			return this._addr;
  		}
  		
  		set addr(addr) {
  			this._addr = addr;
  		}
  		info() {
  			alert(`name : ${ this._name }\nphone : ${ this._phone }\naddr : ${ this._addr }`);
  		}
  	}
  	
  	class Doctor extends Person {// extends로 인해 프로토타입도 옮겨간다. 
  		constructor(name, phone, addr, major) {
  			super(name, phone, addr); // 클래스 내에서의 super은 예약어이지만, exam09에서 function형태로 세운 객체의 super은 단순 변수이다. 
  			this._major = major;
  		}
  	
  		set major(major){
  			this._major = major
  		}
  		
  		get major(major) {
  			return this._major = major
  		}
  	}
  	
  	let person = new Person('홍길동', '010-1111-2222', '서울시 서초구');
  	console.log(person);
  	person.info();
  	
  	let doctor = new Doctor('나최고', '010-3333-4444', '경기도 용인시');
  	console.log(doctor);
  ```

- 

# 표준내장객체

- 기본자료형 객체

  Number, Boolean, String은 자바스크립트의 기본자료형으로, new 연산자를 쓰지 않고도 선언할 수 있다. 하지만 이들이 기본연산자 클래스의 메소드를 쓸 수 있는건 그냥 선언을 해도 메소드를 호출할땐 객체로 변환되었다가 다시 돌아오기 때문이다. 기본 자료형이 속성 또는 메소드를 추가하려면 프로토타입으로 일회용 옷 자체를 바꾸면 된다.  

  ```javascript
  var num = 10;
  	var num2 = new Number(10);
  
  	document.write('num : ' + num + ':' + (typeof num) + '<br>'); 		// number형 (기본자료형) - 프로토타입 정의 불가능 
  	document.write('num2 : ' + num2 + ':' + (typeof num2) + '<br>'); 	// object형 - 프로토타입 정의 가능 
  
  	Object.prototype.info = function() {
  		alert(this)
  	}
  
  	num.info() 	// 기본자료형이라 원래 안되야함 
  	num2.info() // object형이라 원래 얘만 되야함
  	
  ```

- String 객체는 비파괴적 메소드가 주여서 문자열 자체를 바꾸지 않지만, 배열은 파괴적 메소드가 주여서 배열 자체가 바뀐다. 



# 웹브라우저의 자바스크립트

